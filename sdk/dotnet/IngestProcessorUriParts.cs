// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Elasticstack
{
    public static class IngestProcessorUriParts
    {
        /// <summary>
        /// Parses a Uniform Resource Identifier (URI) string and extracts its components as an object. This URI object includes properties for the URI’s domain, path, fragment, port, query, scheme, user info, username, and password.
        /// 
        /// See: https://www.elastic.co/guide/en/elasticsearch/reference/current/uri-parts-processor.html
        /// 
        /// 
        /// {{% examples %}}
        /// ## Example Usage
        /// {{% example %}}
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using Pulumi;
        /// using Elasticstack = Pulumi.Elasticstack;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var parts = Elasticstack.IngestProcessorUriParts.Invoke(new()
        ///     {
        ///         Field = "input_field",
        ///         TargetField = "url",
        ///         KeepOriginal = true,
        ///         RemoveIfSuccessful = false,
        ///     });
        /// 
        ///     var myIngestPipeline = new Elasticstack.IngestPipeline("myIngestPipeline", new()
        ///     {
        ///         Processors = new[]
        ///         {
        ///             parts.Apply(ingestProcessorUriPartsResult =&gt; ingestProcessorUriPartsResult.Json),
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// {{% /example %}}
        /// {{% /examples %}}
        /// </summary>
        public static Task<IngestProcessorUriPartsResult> InvokeAsync(IngestProcessorUriPartsArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<IngestProcessorUriPartsResult>("elasticstack:index/ingestProcessorUriParts:IngestProcessorUriParts", args ?? new IngestProcessorUriPartsArgs(), options.WithDefaults());

        /// <summary>
        /// Parses a Uniform Resource Identifier (URI) string and extracts its components as an object. This URI object includes properties for the URI’s domain, path, fragment, port, query, scheme, user info, username, and password.
        /// 
        /// See: https://www.elastic.co/guide/en/elasticsearch/reference/current/uri-parts-processor.html
        /// 
        /// 
        /// {{% examples %}}
        /// ## Example Usage
        /// {{% example %}}
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using Pulumi;
        /// using Elasticstack = Pulumi.Elasticstack;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var parts = Elasticstack.IngestProcessorUriParts.Invoke(new()
        ///     {
        ///         Field = "input_field",
        ///         TargetField = "url",
        ///         KeepOriginal = true,
        ///         RemoveIfSuccessful = false,
        ///     });
        /// 
        ///     var myIngestPipeline = new Elasticstack.IngestPipeline("myIngestPipeline", new()
        ///     {
        ///         Processors = new[]
        ///         {
        ///             parts.Apply(ingestProcessorUriPartsResult =&gt; ingestProcessorUriPartsResult.Json),
        ///         },
        ///     });
        /// 
        /// });
        /// ```
        /// {{% /example %}}
        /// {{% /examples %}}
        /// </summary>
        public static Output<IngestProcessorUriPartsResult> Invoke(IngestProcessorUriPartsInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<IngestProcessorUriPartsResult>("elasticstack:index/ingestProcessorUriParts:IngestProcessorUriParts", args ?? new IngestProcessorUriPartsInvokeArgs(), options.WithDefaults());
    }


    public sealed class IngestProcessorUriPartsArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Description of the processor.
        /// </summary>
        [Input("description")]
        public string? Description { get; set; }

        /// <summary>
        /// Field containing the URI string.
        /// </summary>
        [Input("field", required: true)]
        public string Field { get; set; } = null!;

        /// <summary>
        /// Conditionally execute the processor
        /// </summary>
        [Input("if")]
        public string? If { get; set; }

        /// <summary>
        /// Ignore failures for the processor.
        /// </summary>
        [Input("ignoreFailure")]
        public bool? IgnoreFailure { get; set; }

        /// <summary>
        /// If true, the processor copies the unparsed URI to `&lt;target_field&gt;.original.`
        /// </summary>
        [Input("keepOriginal")]
        public bool? KeepOriginal { get; set; }

        [Input("onFailures")]
        private List<string>? _onFailures;

        /// <summary>
        /// Handle failures for the processor.
        /// </summary>
        public List<string> OnFailures
        {
            get => _onFailures ?? (_onFailures = new List<string>());
            set => _onFailures = value;
        }

        /// <summary>
        /// If `true`, the processor removes the `field` after parsing the URI string. If parsing fails, the processor does not remove the `field`.
        /// </summary>
        [Input("removeIfSuccessful")]
        public bool? RemoveIfSuccessful { get; set; }

        /// <summary>
        /// Identifier for the processor.
        /// </summary>
        [Input("tag")]
        public string? Tag { get; set; }

        /// <summary>
        /// Output field for the URI object.
        /// </summary>
        [Input("targetField")]
        public string? TargetField { get; set; }

        public IngestProcessorUriPartsArgs()
        {
        }
        public static new IngestProcessorUriPartsArgs Empty => new IngestProcessorUriPartsArgs();
    }

    public sealed class IngestProcessorUriPartsInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Description of the processor.
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Field containing the URI string.
        /// </summary>
        [Input("field", required: true)]
        public Input<string> Field { get; set; } = null!;

        /// <summary>
        /// Conditionally execute the processor
        /// </summary>
        [Input("if")]
        public Input<string>? If { get; set; }

        /// <summary>
        /// Ignore failures for the processor.
        /// </summary>
        [Input("ignoreFailure")]
        public Input<bool>? IgnoreFailure { get; set; }

        /// <summary>
        /// If true, the processor copies the unparsed URI to `&lt;target_field&gt;.original.`
        /// </summary>
        [Input("keepOriginal")]
        public Input<bool>? KeepOriginal { get; set; }

        [Input("onFailures")]
        private InputList<string>? _onFailures;

        /// <summary>
        /// Handle failures for the processor.
        /// </summary>
        public InputList<string> OnFailures
        {
            get => _onFailures ?? (_onFailures = new InputList<string>());
            set => _onFailures = value;
        }

        /// <summary>
        /// If `true`, the processor removes the `field` after parsing the URI string. If parsing fails, the processor does not remove the `field`.
        /// </summary>
        [Input("removeIfSuccessful")]
        public Input<bool>? RemoveIfSuccessful { get; set; }

        /// <summary>
        /// Identifier for the processor.
        /// </summary>
        [Input("tag")]
        public Input<string>? Tag { get; set; }

        /// <summary>
        /// Output field for the URI object.
        /// </summary>
        [Input("targetField")]
        public Input<string>? TargetField { get; set; }

        public IngestProcessorUriPartsInvokeArgs()
        {
        }
        public static new IngestProcessorUriPartsInvokeArgs Empty => new IngestProcessorUriPartsInvokeArgs();
    }


    [OutputType]
    public sealed class IngestProcessorUriPartsResult
    {
        /// <summary>
        /// Description of the processor.
        /// </summary>
        public readonly string? Description;
        /// <summary>
        /// Field containing the URI string.
        /// </summary>
        public readonly string Field;
        /// <summary>
        /// Internal identifier of the resource.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// Conditionally execute the processor
        /// </summary>
        public readonly string? If;
        /// <summary>
        /// Ignore failures for the processor.
        /// </summary>
        public readonly bool? IgnoreFailure;
        /// <summary>
        /// JSON representation of this data source.
        /// </summary>
        public readonly string Json;
        /// <summary>
        /// If true, the processor copies the unparsed URI to `&lt;target_field&gt;.original.`
        /// </summary>
        public readonly bool? KeepOriginal;
        /// <summary>
        /// Handle failures for the processor.
        /// </summary>
        public readonly ImmutableArray<string> OnFailures;
        /// <summary>
        /// If `true`, the processor removes the `field` after parsing the URI string. If parsing fails, the processor does not remove the `field`.
        /// </summary>
        public readonly bool? RemoveIfSuccessful;
        /// <summary>
        /// Identifier for the processor.
        /// </summary>
        public readonly string? Tag;
        /// <summary>
        /// Output field for the URI object.
        /// </summary>
        public readonly string? TargetField;

        [OutputConstructor]
        private IngestProcessorUriPartsResult(
            string? description,

            string field,

            string id,

            string? @if,

            bool? ignoreFailure,

            string json,

            bool? keepOriginal,

            ImmutableArray<string> onFailures,

            bool? removeIfSuccessful,

            string? tag,

            string? targetField)
        {
            Description = description;
            Field = field;
            Id = id;
            If = @if;
            IgnoreFailure = ignoreFailure;
            Json = json;
            KeepOriginal = keepOriginal;
            OnFailures = onFailures;
            RemoveIfSuccessful = removeIfSuccessful;
            Tag = tag;
            TargetField = targetField;
        }
    }
}
